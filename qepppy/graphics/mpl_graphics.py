import numpy as np
from matplotlib.artist import Artist
from matplotlib.axes import Axes

from .. import types, utils

# from ..types import types.LArray3, types.LArray3_3, types.LArrayN


def draw_cell(
        ax: Axes,
        cell: types.LArray3_3,
        center: types.LArray3 = np.zeros(3)
        ) -> list[Artist]:
    """Draw a cell centered on 'center'.

    Args:
        ax (Axes): matplotlib 3D axis object
        cell (types.LArray3_3): A 3x3 matrix of basis vectors as rows.
        center (types.LArray3, optional): The center for the cell. Defaults to [0,0,0].

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    V = cell
    res = []
    for n1 in range(3):
        orig = np.array(center)
        v0 = V[n1]
        for n2 in range(4):
            v = np.array(np.vstack((orig, orig + v0)))
            if n2 == n1:
                orig = V[(n2+1)%3] + V[(n2+2)%3]
            else:
                orig = V[n2%3]
            app = ax.plot(v[:,0], v[:,1], v[:,2], color='black', linewidth=0.5)
            res.append(app)
        app = ax.plot(v[:,0], v[:,1], v[:,2], color='black', linewidth=0.5)
        res.append(app)

    return res

def draw_Wigner_Seitz(
        ax: Axes,
        recipr: types.LArray3_3,
        draw_corners: bool = True,
        edge_kwargs: dict = {
            'color': 'black'
        },
        corner_kwargs: dict={
            'color': 'green'
        }
        ) -> list[Artist]:
    """Draw the Wigner Seitz cell for the lattice.

    Args:
        ax (Axes): matplotlib 3D axis object
        recipr (types.LArray3_3): A 3x3 matrix of reciprocal basis vectors as rows.
        draw_corners (bool, optional): Whether to draw the corners as dots. Defaults to True.
        edge_kwargs (_type_, optional): Dictionary of arguments to be passed to matplotlib to draw the edges.
            Defaults to { 'color': 'black' }.
        corner_kwargs (_type_, optional): Dictionary of arguments to be passed to matplotlib to draw the corners.
            Defaults to { 'color': 'green' }.

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    res = []
    dim = len(recipr)
    from scipy.spatial import KDTree, Voronoi
    L = utils.generate_repetition_grid([[-1,0,1]]*dim, vect_matrix=recipr)

    vor = Voronoi(L)
    P = vor.vertices
    R = vor.ridge_vertices

    tree       = KDTree(L)
    d,i        = tree.query([0,]*dim)
    dist, ind  = tree.query(P, k=L.shape[0])
    w          = (np.abs(dist.T - dist.T[0]) > 1E-5).T
    closest    = ind.copy()
    closest[w] = -1

    cond    = np.where([not i in a for a in closest])[0]
    P[cond] = np.zeros(dim)


    for i1, e in enumerate(R):
        for i2, r in enumerate(e):
            if r in cond:
                R[i1][i2] = -1

    if draw_corners:
        app = ax.scatter(*P.T, **corner_kwargs)
        res.append(app)

    for vert in R:
        vert.append(vert[0])
        v = np.asarray(vert)
        if np.all(v >= 0):
            app = ax.plot(*P[v].T, **edge_kwargs)
            res.extend(app)

    return res

def draw_plane(
        ax: Axes,
        v1: types.LArray3,
        v2: types.LArray3,
        origin: types.LArray3 = np.zeros(3),
        surface_kwargs: dict = {}
        ) -> list[Artist]:
    """Draw a plane defined by the vectors v1 and v2.

    Args:
        ax (Axes): matplotlib 3D axis object
        v1 (types.LArray3): The first vector defining the plane.
        v2 (types.LArray3): The second vector defining the plane.
        origin (types.LArray3, optional): The origin of the plane.
            Defaults to np.zeros(3).
        surface_kwargs (dict, optional): Dictionary of arguments to be passed to matplotlib to draw the surface.
            Defaults to {}.

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    a, b = np.meshgrid([0,1], [0,1], indexing='ij')
    app = np.dot(np.array([a.flatten(), b.flatten()]).T, [v1,v2])
    xx,yy,zz = (app + origin).T.reshape(3,2,2)

    res = ax.plot_surface(xx,yy,zz, **surface_kwargs)

    return [res]

def draw_sphere(
        ax: Axes,
        radius: float = 1,
        center: types.LArray3 = np.zeros(3),
        long: int = 10,
        lat: int = 7,
        surface_kwargs = {}
        ) -> list[Artist]:
    """Draw a sphere centered on 'center'.

    Args:
        ax (Axes): matplotlib 3D axis object
        radius (float, optional): The radius of the sphere. Defaults to 1.
        center (types.LArray3, optional): The center of the sphere.
            Defaults to np.zeros(3).
        long (int, optional): The longitudinal resolution (number of slicese). Defaults to 10.
        lat (int, optional): The latitudinal resolution (number of slices). Defaults to 7.
        surface_kwargs (dict, optional): Dictionary of arguments to be passed to matplotlib to draw the surface.
            Defaults to {}.

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    center = np.array(center).reshape(-1,3)

    u = np.linspace(0, 2 * np.pi, long)
    v = np.linspace(0, np.pi, lat)
    x0 = radius * np.outer(np.cos(u), np.sin(v))
    y0 = radius * np.outer(np.sin(u), np.sin(v))
    z0 = radius * np.outer(np.ones(np.size(u)), np.cos(v))

    res = []
    for (xoff,yoff,zoff) in center:
        app = ax.plot_surface(x0+xoff, y0+yoff, z0+zoff, **surface_kwargs)
        res.append(app)

    return res


def draw_cylinder(
        ax: Axes,
        radius: float = 1,
        axis: types.LArray3 = np.array([0,0,1]),
        start: types.LArray3 = np.zeros(3),
        surface_kwargs = {'color': 'b'}
        ) -> list[Artist]:
    """Draw a cylinder centered on 'center'.

    Args:
        ax (Axes): matplotlib 3D axis object
        radius (float, optional): The radius of the cylinder. Defaults to 1.
        axis (types.LArray3, optional): The ceneter axis of the cilinder.
            Defines both the direction and the length of the cilinder.
            Defaults to np.array([0,0,1]).
        start (types.LArray3, optional): The start point for the cilinder.
            Defaults to np.zeros(3).
        surface_kwargs (dict, optional): Dictionary of arguments to be passed to matplotlib to draw the surface.
        Defaults to {'color': 'b'}.

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    x0, y0, z0 = start

    norm   = np.linalg.norm(axis)
    axis  /= norm
    c_teta = axis[2]
    s_teta = np.sqrt(1 - c_teta**2)
    c_phi  = axis[0]/s_teta if s_teta else 1
    s_phi  = axis[1]/s_teta if s_teta else 0

    u = np.linspace(0, 2*np.pi, 8)
    v = np.linspace(0, 1*norm, 2)

    x = radius * np.outer(np.cos(u)*s_phi + np.sin(u)*c_phi*c_teta, np.ones(np.size(v)))   + axis[0] * v + x0
    y = radius * np.outer(-np.cos(u)*c_phi + np.sin(u)*s_phi*c_teta, np.ones(np.size(v)) ) + axis[1] * v + y0
    z = radius * np.outer(-np.sin(u)*s_teta, np.ones(np.size(v)))                          + axis[2] * v + z0

    return [ax.plot_surface(x, y, z, **surface_kwargs)]

def draw_bond(
        ax: Axes,
        start: types.LArray3,
        end: types.LArray3,
        color1: str = 'black',
        color2: str = 'green',
        graph_lvl: int = 0
        ) -> list[Artist]:
    """Higher level function to draw a bond between two points.
    Supports server level of detail.

    Args:
        ax (Axes): matplotlib 3D axis object
        start (types.LArray3): The start point for the bond.
        end (types.LArray3): The end point for the bond.
        color1 (str, optional): The color of the bond from start up to the middle point.
            Defaults to 'black'.
        color2 (str, optional): The color of the bond from the middle point up to the end.
            Defaults to 'green'.
        graph_lvl (int, optional): The level of details to be included in the plot.
            Defaults to 0.
            0: Only one line between the two points
            1: Two lines, one from start to middle and one from middle to end with respective colors
            2: Same as 1
            3: A cylinder with the respective color of the bond from start to end
               If the cilinder have the same color, only one is drawn for efficiency

    Raises:
        ValueError: If graph_lvl is > 3

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    res = []
    if graph_lvl == 0:
        v = np.vstack((start, end))
        app = ax.plot(v[:,0], v[:,1], v[:,2], color='black', linewidth=1.5)
        res.append(app)
    elif graph_lvl == 1 or graph_lvl == 2:
        mid = (start + end) / 2
        v = np.vstack((start, mid))
        app = ax.plot(v[:,0], v[:,1], v[:,2], color=color1, linewidth=3.5)
        res.append(app)
        v = np.vstack((mid, end))
        app = ax.plot(v[:,0], v[:,1], v[:,2], color=color2, linewidth=3.5)
        res.append(app)
    elif graph_lvl == 3:
        mid = (start + end) / 2
        if color1 != color2:
            app = draw_cylinder(ax, radius=0.15, axis=(end-start)/2, start=start,  color=color1)
            res.extend(app)
            app = draw_cylinder(ax, radius=0.15, axis=(end-start)/2, start=mid, color=color2)
            res.extend(app)
        else:
            app = draw_cylinder(ax, radius=0.15, axis=end-start, start=start,  color=color1)
            res.extend(app)
    else:
        raise ValueError("arg 'graph_lvl' must be <= 3")

    return res

def draw_atom(
        ax: Axes,
        X: types.LArrayN,
        Y: types.LArrayN,
        Z: types.LArrayN,
        color: str = 'k',
        name: str = '',
        radius: float = 1,
        graph_lvl: int = 0
        ) -> list[Artist]:
    """Higher level function to draw a set of atoms.

    Args:
        ax (Axes): matplotlib 3D axis object
        X (types.LArrayN): An array of x coordinates for the atoms.
        Y (types.LArrayN): An array of y coordinates for the atoms.
        Z (types.LArrayN): An array of z coordinates for the atoms.
        color (str, optional): The color for the set of atoms. Defaults to 'k'.
        name (str, optional): The name for the set of atoms. Defaults to ''.
        radius (float, optional): The dimension of the points or radius of the spheres (see graph_lvl).
            Defaults to 1.
        graph_lvl (int, optional): The level of details to be included in the plot.
            Defaults to 0.
            0: Points
            1: Same as 0
            2: Points with spheres
            3: Same as 2

    Raises:
        ValueError: If graph_lvl is > 3

    Returns:
        list[Artist]: List of matplotlib artists generated by the function.
    """
    res = []
    if graph_lvl == 0 or graph_lvl == 1:
        app = ax.scatter(
            X, Y, Z,
            s=80*radius,
            marker='o',
            depthshade=False,
            c=color,
            label=name
            )
        res.append(app)
    elif graph_lvl == 2 or graph_lvl == 3:
        app = ax.scatter(
            X, Y, Z,
            s=10,
            marker='o',
            depthshade=False,
            c=color,
            label=name
            )
        res.append(app)
        for x,y,z in zip(X,Y,Z):
            app = draw_sphere(ax, radius=radius*0.3, center=[x,y,z], color=color)
            res.extend(app)
    else:
        raise ValueError("arg 'graph_lvl' must be <= 3")

    return res
